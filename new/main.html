<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js2020</title>
    <link rel="stylesheet" href="./main.css">
</head>

<body>
    <div class="link" id="list">
        <div class="js2020">
            <h2>{{ js2020 }}</h2>
            <ol>
                <li>
                    <div class="newName">globalThis</div>
                    <button v-on:click="consoleGlobaleThis">输出globalThis</button>
                    <table>
                        <tr>
                            <td></td>
                            <td>Window</td>
                            <td>Self</td>
                            <td>globalThis</td>
                        </tr>
                        <tr>
                            <td>浏览器</td>
                            <td class="yes">√</td>
                            <td class="yes">√</td>
                            <td class="yes">√</td>
                        </tr>
                        <tr>
                            <td>web workers</td>
                            <td class="x">x</td>
                            <td class="yes">√</td>
                            <td class="yes">√</td>
                        </tr>
                        <tr>
                            <td>Node</td>
                            <td class="x">x</td>
                            <td class="x">x</td>
                            <td class="yes">√</td>
                        </tr>
                    </table>
                </li>
                <li>
                    <div class="newName">promise.allSettled</div>
                    <div>
                        <pre>
<code>let p1 = new Promise((resolve, reject) => </code>
    <code>setTimeout(resolve(1), 200));</code>
<code>let p2 = new Promise((resolve, reject) => </code>
    <code>setTimeout(reject("error"), 300));</code>
<code>let p3 = new Promise((resolve, reject) => </code>
    <code>setTimeout(resolve(2), 400));</code>
<code></code>
<code>Promise.all([p1,p2,p3])</code>
<code>  .then((res) => console.log(res))</code>
<code>  .catch((e) => console.log(e))</code></pre>
<div>使用: promise.allSettled:</div>
<pre>
<code>Promise.allSettled([p1,p2,p3])</code>
<code>  .then((res) => console.log(res))</code>
<code>  .catch((e) => console.log(e))</code></pre>
                    </div>
                    <button v-on:click="pas">输出</button>
                </li>
                <li>
                    <div class="newName">空位合并操作符(Nullish coalescing Operator) - ??</div>
                    <div>如果属性不存在，则为 ?? 后的值；如果属性存在，就是该属性的值，即使该值是0</div>
                    <button v-on:click="nco">输出</button>
                </li>
                <li>
                    <div class="newName">可选链操作符(Optinal Chaining Operator)</div>
                    <div>当需要访问嵌套在对象内部好几层的属性时，如果属性不存在会报错； - 把 . 换成 ?. </div>
                    <button v-on:click="oco">输出</button>
                </li>
                <li>
                    <div class="newName">BigInt</div>
                    <div>可以表示更大的数字 - 在定义时数字后面加上 n 即可；或者使用构造函数 BigInt() 创建；</div>
                    <button v-on:click="bigint">输出</button>
                </li>
            </ol>
        </div>
        <div class="js2021">
            <h2>{{ js2021 }}</h2>
            <ol>
                <li>
                    <div class="newName">String.replaceAll</div>
                    <div>相当于正则表达式中的 /g </div>
                    <button v-on:click="sra">输出</button>
                </li>
                <li>
                    <div class="newName">Promise.any</div>
                    <div>只要其中任一promise成功即可返回，忽略reject;</div>
                    <div>与Promise.any()方法不同，Promise.race()方法返回最快的那个。</div>
                    <button v-on:click="pa">输出</button>
                </li>
                <li>
                    <div class="newName">||= &&= </div>
                    <div>a ||= b;a为true时，把b赋值给a</div>
                    <div>a &&= b;a，b都为true时，把b赋值给a</div>
                    <button v-on:click="nul()">输出</button>
                </li>
                <li>
                    <div class="newName">10_000_000</div>
                    <div>可以用 _ 分割数字，更清楚的看到位数</div>
                    <button v-on:click="number_(10_000_000)">输出</button>
                </li>
                <li>
                    <div class="newName">私有方法和字段 - #</div>
                    <div></div>
                    <button @click="pfun">输出</button>
                </li>
            </ol>
        </div>
        <div class="debounceAthrottling">
            <h2>{{ d2a }}</h2>
            <ol>
                <li>
                    <div class="newName">节流</div>
                    <div>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。</div>
                    <button v-on:click="throttle(thr,2000)">输出</button>
                </li>
                <li>
                    <div class="newName">防抖</div>
                    <div>当持续触发事件时,一定时间段内没有再触发事件,事件处理函数才会执行一次,如果设定的时间到来之前,又一次触发了事件,就重新开始延时。</div>
                    <div>类似于电梯门的原理</div>
                    <button @click="debounce(deb,1000)">输出</button>
                </li>
            </ol>
        </div>
        <div class="arrow">
            <h2>{{ arrow }}</h2>
            <ol>
                <li>
                    <div class="newName">箭头函数与普通函数的区别</div>
                    <table>
                        <tr>
                            <td></td>
                            <td>普通函数</td>
                            <td>箭头函数</td>
                        </tr>
                        <tr>
                            <td>基本格式</td>
                            <td><span class="code">function(){}</span></td>
                            <td><span class="code">()=>{}</span></td>
                        </tr>
                        <tr>
                            <td>区别</td>
                            <td colspan="2">
                                <ol>
                                    <li>箭头函数不能用 <span class="code">new</span> 来创建构造函数的实例，而普通函数可以</li>
                                    <li>箭头函数没有<span class="code">arguments</span>对象</li>
                                    <li>普通函数的<span class="code">this</span>指向是动态的，而箭头函数的<span class="code">this</span>是定时决定的。</li>
                                    <li>箭头函数不能通过<span class="code">bind</span>、<span class="code">call</span>、<span class="code">apply</span>来改变<span class="code">this</span>的值</li>
                                </ol>
                            </td>
                        </tr>
                        <tr>
                            <td>new和原型</td>
                            <td>有</td>
                            <td>没有</td>
                        </tr>
                        <tr>
                            <td>arguments，super</td>
                            <td>有</td>
                            <td>没有，需调用外围</td>
                        </tr>
                        <tr>
                            <td>this指向</td>
                            <td>动态</td>
                            <td>一般是全局对象，被普通函数包含指向上一层</td>
                        </tr>
                        <tr>
                            <td>apply、call、bind</td>
                            <td>修改this的值</td>
                            <td>不可修改this的值</td>
                        </tr>
                    </table>
                </li>
            </ol>
        </div>
    </div>
    <script src="https://unpkg.com/vue@next"></script>
    <script>
        var timer,timer2; // 节流与防抖需要的全局变量
        const app = Vue.createApp({
            data(){
                return {
                    js2020: 'JavaScript 2020 新特性',
                    js2021: 'JavaScript 2021 新特性',
                    d2a: 'debounce and throttle（防抖与节流）',
                    arrow: '箭头函数'
                }
            },
            methods: {
                consoleGlobaleThis(){
                    console.log("globalThis: ",globalThis);
                },
                pas(){
                    let p1 = new Promise((resolve, reject) =>
                        setTimeout(resolve(1), 200));
                    let p2 = new Promise((resolve, reject) =>
                        setTimeout(reject("error"), 300));
                    let p3 = new Promise((resolve, reject) =>
                        setTimeout(resolve(2), 400));
                    // Promise.all([p1,p2,p3])
                    //     .then((res) => console.log(res))
                    //     .catch((e) => console.log(e))

                    Promise.allSettled([p1,p2,p3])
                        .then((res) => console.log(res))
                        .catch((e) => console.log(e))
                },
                nco(){
                    let s = {
                        's': 0
                    }
                    console.log(s['s']??100);
                    console.log(s['a']??100);
                },
                oco(){
                    let m = {};
                    console.log(m?.info?.name);
                },
                bigint(){
                    let a = 12n;
                    let b = BigInt(23);
                    console.log(a);
                    console.log(b);
                },
                sra(){
                    const s = 'string replace all';
                    console.log('s:',s)
                    console.log("s.replace('l','#'):",s.replace('l','#'))
                    console.log("s.replaceAll('l','#'):",s.replaceAll('l','#'))
                    console.log("s.replace(/[l]/g,'#')",s.replace(/[l]/g,'#'))
                },
                pa(){
                    let p1 = new Promise((resolve, reject) =>
                        setTimeout(resolve(1), 2000));
                    let p2 = new Promise((resolve, reject) =>
                        setTimeout(reject("error"), 200));
                    let p3 = new Promise((resolve, reject) =>
                        setTimeout(resolve(2), 3000));
                    Promise.race([p2,p1,p3])
                        .then((res) => console.log(res))
                        .catch((e) => console.log(e))

                    Promise.any([p1,p2,p3])
                        .then((res) => console.log(res))
                        .catch((e) => console.log(e))
                },
                nul(){
                    let a = '',b = 'b',c = 'c';
                    a ||= b;
                    c &&= b;
                    console.log(a);
                    console.log(c);
                },
                number_(number){
                    console.log(number);
                },
                pfun(){
                    class Circle{
                        static #PI = 3.14;
                        static area(r){ // 静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。
                            return r*r*Circle.#PI;
                        }
                    }
                    console.log(Circle.area(3));
                },
                deb(){
                    console.warn('防抖按钮被点击');
                    // console.log(this);
                },
                debounce(func, delay){
                    let self = this;
                    let args = arguments;
                    clearTimeout(timer);
                    timer = setTimeout(function(){
                        func.apply(self, args);
                    },delay);
                },
                thr(){
                    let r = Math.floor(Math.random()*255);
                    let g = Math.floor(Math.random()*255);
                    let b = Math.floor(Math.random()*255);
                    let txtColor;
                    if(r>110 && g>110 && b>110){
                        txtColor = '#222';
                    } else {
                        txtColor = '#fff';
                    }
                    const style = `color: ${txtColor};background-color: rgb(${r},${g},${b});padding: 2px 6px;border-radius: 5px;`;
                    console.log('%c节流事件',style);
                },
                throttle(func, delay){
                    if(timer2) return; // timer2被赋值了，直接返回，如果timer2为 null，执行下面赋值操作 ！！！
                    timer2 = setTimeout(function(){
                        func();
                        timer2 = null;
                    },delay);
                }
            }
        }).mount('#list');
    </script>
</body>

</html>